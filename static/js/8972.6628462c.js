"use strict";(self["webpackChunkonepic"]=self["webpackChunkonepic"]||[]).push([[8972],{78972:function(t,e,i){i.r(e),i.d(e,{default:function(){return m}});var a=i(61445),o=i(93622),r=i(92454),s=i(58006),n=(i(94315),i(15055),i(77623)),h=i(74952),d=i(54572),p=i(30482),l=i(31698),c=i(42769);let u=class extends((0,c.Z)((0,d.y)(l.Z))){update(t){this._strategy.update(t).catch((t=>{(0,r.D_)(t)||o.Z.getLogger(this.declaredClass).error(t)})),this.notifyChange("updating")}attach(){this._bitmapContainer=new h.c,this.container.addChild(this._bitmapContainer),this._strategy=new p.Z({container:this._bitmapContainer,fetchSource:this.fetchBitmapData.bind(this),requestUpdate:this.requestUpdate.bind(this)})}detach(){this._strategy.destroy(),this._strategy=null,this.container.removeChild(this._bitmapContainer),this._bitmapContainer.removeAllChildren()}moveStart(){}viewChange(){}moveEnd(){this.requestUpdate()}fetchBitmapData(t,e,i){return this.layer.fetchImageBitmap(t,e,i)}async doRefresh(){this.requestUpdate()}isUpdating(){return this._strategy.updating||this.updateRequested}};(0,a._)([(0,s.Cb)()],u.prototype,"_strategy",void 0),(0,a._)([(0,s.Cb)()],u.prototype,"updating",void 0),u=(0,a._)([(0,n.j)("esri.views.2d.layers.BaseDynamicLayerView2D")],u);const m=u},30482:function(t,e,i){i.d(e,{Z:function(){return w}});i(57658);var a=i(61445),o=i(92698),r=(i(81653),i(92454)),s=i(58006),n=(i(94315),i(15055),i(77623)),h=i(74440),d=i(54597),p=i(86052);const l=Math.PI/180;function c(t){return t*l}function u(t,e){const i=c(e.rotation),a=Math.abs(Math.cos(i)),o=Math.abs(Math.sin(i)),[r,s]=e.size;return t[0]=Math.round(s*o+r*a),t[1]=Math.round(s*a+r*o),t}function m(t,e,i,a){const[o,r]=e,[s,n]=a,h=.5*i;return t[0]=o-h*s,t[1]=r-h*n,t[2]=o+h*s,t[3]=r+h*n,t}var g=i(15347),_=i(86491),y=i(93752);const f=(0,h.Ue)(),x=[0,0],b=new y.Z(0,0,0,0),C={container:null,fetchSource:null,requestUpdate:null,imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let v=class extends o.Z{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=C.hidpi,this.imageMaxWidth=C.imageMaxWidth,this.imageMaxHeight=C.imageMaxHeight,this.imageRotationSupported=C.imageRotationSupported,this.imageNormalizationSupported=C.imageNormalizationSupported,this.update=(0,r.Ds)((async(t,e)=>{if((0,r.k_)(e),!t.stationary||this.destroyed)return;const i=t.state,a=(0,d.C5)(i.spatialReference),o=this.hidpi?t.pixelRatio:1,s=this.imageNormalizationSupported&&i.worldScreenWidth&&i.worldScreenWidth<i.size[0],n=this.imageMaxWidth??0,h=this.imageMaxHeight??0;s?(x[0]=i.worldScreenWidth,x[1]=i.size[1]):this.imageRotationSupported?(x[0]=i.size[0],x[1]=i.size[1]):u(x,i);const p=Math.floor(x[0]*o)>n||Math.floor(x[1]*o)>h,l=a&&(i.extent.xmin<a.valid[0]||i.extent.xmax>a.valid[1]),c=!this.imageNormalizationSupported&&l,m=!p&&!c,g=this.imageRotationSupported?i.rotation:0,_=this.container.children.slice();if(m){const t=s?i.paddedViewState.center:i.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(i,x,t,i.resolution,g,o,e)}else{let t=Math.min(n,h);c&&(t=Math.min(i.worldScreenWidth,t)),this._imagePromise=this._tiledExport(i,t,o,e)}try{const t=await this._imagePromise??[];(0,r.k_)(e);const i=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=t;for(const e of _)t.includes(e)||i.push(e.fadeOut().then((()=>{e.remove(),e.destroy()})));for(const e of t)i.push(e.fadeIn());await Promise.all(i)}catch(b){this._imagePromise=null,(0,r.r9)(b)}}),5e3),this.updateExports=(0,r.Ds)((async t=>{const e=[];for(const i of this.container.children){if(!i.visible||!i.stage)return;e.push(t(i).then((()=>{i.invalidateTexture(),i.requestRender()})))}this._imagePromise=(0,r.as)(e).then((()=>this._imagePromise=null)),await this._imagePromise}))}destroy(){this.bitmaps.forEach((t=>t.destroy())),this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}async _export(t,e,i,a,o,s){const n=await this.fetchSource(t,Math.floor(e*o),Math.floor(i*o),{rotation:a,pixelRatio:o,signal:s});(0,r.k_)(s);const h=new g.eY(null,{immutable:!0,requestRenderOnSourceChangedEnabled:!0});return h.x=t.xmin,h.y=t.ymax,h.resolution=t.width/e,h.rotation=a,h.pixelRatio=o,h.opacity=0,this.container.addChild(h),await h.setSourceAsync(n,s),(0,r.k_)(s),h}async _singleExport(t,e,i,a,o,r,s){m(f,i,a,e);const n=(0,h.HH)(f,t.spatialReference);return[await this._export(n,e[0],e[1],o,r,s)]}_tiledExport(t,e,i,a){const o=p.Z.create({size:e,spatialReference:t.spatialReference,scales:[t.scale]}),r=new _.Z(o),s=r.getTileCoverage(t);if(!s)return null;const n=[];return s.forEach(((o,s,d,p)=>{b.set(o,s,d,0),r.getTileBounds(f,b);const l=(0,h.HH)(f,t.spatialReference);n.push(this._export(l,e,e,0,i,a).then((t=>(0!==p&&(b.set(o,s,d,p),r.getTileBounds(f,b),t.x=f[0],t.y=f[3]),t))))})),Promise.all(n)}};(0,a._)([(0,s.Cb)()],v.prototype,"_imagePromise",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"bitmaps",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"container",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"fetchSource",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"hidpi",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"imageMaxWidth",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"imageMaxHeight",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"imageRotationSupported",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"imageNormalizationSupported",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"requestUpdate",void 0),(0,a._)([(0,s.Cb)()],v.prototype,"updating",null),v=(0,a._)([(0,n.j)("esri.views.2d.layers.support.ExportStrategy")],v);const w=v},42769:function(t,e,i){i.d(e,{Z:function(){return d}});var a=i(61445),o=i(93622),r=i(92454),s=i(18105),n=i(58006),h=(i(94315),i(15055),i(77623));const d=t=>{let e=class extends t{initialize(){this.handles.add((0,s.on)((()=>this.layer),"refresh",(t=>{this.doRefresh(t.dataChanged).catch((t=>{(0,r.D_)(t)||o.Z.getLogger(this.declaredClass).error(t)}))})),"RefreshableLayerView")}};return(0,a._)([(0,n.Cb)()],e.prototype,"layer",void 0),e=(0,a._)([(0,h.j)("esri.layers.mixins.RefreshableLayerView")],e),e}}}]);